# 三次握手四次挥手
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1630323244378-7ff35e7d-ddf5-4da2-b0c9-153b3f14cfd3.png#clientId=u7a62e21b-f8b1-4&from=paste&id=ub267273c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=959&originalType=url&ratio=1&size=281774&status=done&style=none&taskId=ub2543db2-605e-4ca9-9381-6aaa72997b6)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1630330411410-3632e892-f633-40c6-b9ce-f821a7b72f0e.png#clientId=u5d476051-12c5-4&from=paste&id=ua9c602a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=849&originWidth=1876&originalType=url&ratio=1&size=763349&status=done&style=none&taskId=u36194c05-04e8-49de-8600-4ceb2ae6296)
# MTU和MSS区别
MTU： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小；以普遍使用的以太网接口为例，缺省MTU=1500 Byte，这是以太网接口对IP层的约束，如果IP层有<=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有> 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。

MSS：Maximum Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，MSS是TCP用来限制application层最大的发送字节数。如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。

# 关于UDP和TCP：
对比：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1633871847877-0727ebc0-0ea9-4f88-8501-97fa3f91a923.png#clientId=u105d3b52-8b69-4&from=paste&id=u2484c16a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=816&originWidth=1893&originalType=url&ratio=1&size=547117&status=done&style=none&taskId=u0c83b423-7194-4e46-aa00-4f1e4401d41)
HTTP总体响应时间= DNS域名解析时间 + TCP 连接建立时间 + HTTP交易时间
DNS域名解析时间 = TCP连接时间 + DNS交易时间
DNS域名解析时间 = DNS交易时间
由于历史的原因，互联网上物理链路的最小MTU = 576，基于UDP传输的DNS为了限制报文不超过576，所以将DNS报文限制在512字节。
当基于UDP传输的DNS有1000字节需要传输时，会将1000字节砍成两个500字节的报文传输?
不会!只会保留前面的512字节，剩下的488字节会抛弃!因为DNS没有字段来标识报文ID，比如1、2、3，所以默认只有一个报文，剩下的多余数据只有被扔的份！
这样一旦DNS查询应答超过512字节，基于UDP的DNS就只有截短为512字节，那么用户得到的DNS应答就是不完整的。
为了克服这种困难，最简单的方式就是使用TCP，来重新查询。尽管交易时间可能比较长，但毕竟可以得到完整的答案，总比得到不完整的答案要好。

# 数据链路层
## 可靠传输实现：
在停止等待协议中：
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1630206651286-88b620ee-4f11-4ce5-99bb-7471c62fbca8.png#clientId=uaf6ab322-1f9d-4&from=paste&height=209&id=Mvs4R&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=452&originalType=url&ratio=1&size=229483&status=done&style=none&taskId=uc3e1171d-76a8-4f98-8ddd-dbb4c1f6e86&width=131)
在每个数据发送后，接收方接到后会发送ACK（确认）信号确认无误收到，发送收到ACK信号后便开始发送下一个数据。
接收方检测收到数据出现误码后，**会发送NAK（否认）信号**，发送方接收到NAK信号后会重新发送缓存区中的数据。
因此，在此过程中，发送方与接收方一直处于一种停止等待对方的过程，在此过程中要进行确认与否认，这也是停止-等待协议的最基本原则。

### 停止等待：
接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。
为了让接收方能够判断所收到的数据分组是否是重复的，需要给**数据分组**编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1
为了让发送方能够判断所收到的ACK分组是否是重复的，需要给**ACK分组编号**，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。
超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。
在数据链路层点对点的往返时间比较确定，重传时间比较好设定。
然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。
### 回退N帧协议：
**发送方**

- 发送窗口尺寸Wr的取值范围是Ⅰ< w, ≤ 2"-1其中，n是构成分组序号的比特数量。
- W,= 1停止-等待协议
- w, > 2”-1接收方无法分辨新、旧数据分组发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去;
- 发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动;
- 发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定。
- 发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传，这就是回退N帧协议名称的由来。

**接收方**

- 接收方的接收窗口尺寸WR的取值范围是Wp= 1 因此接收方只能按序接收数据分组。
- 接收方只接收序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组。为了减少开销，接收方不一定每收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组,
- 而是可以在连续收到好几个按序到达且无误码的数据分组后(由具体实现决定)，才针对最后一个数据分组发送确认分组，这称为累积确认;或者可以在自己有数据分组要发送时才对之前按序接收且无误码的数据分组进行捎带确认;
- 接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认;
### 选择重传
**发送方**

- 发送窗口尺寸Wr的取值范围是Ⅰ<w, ≤ 2”'其中，n是构成分组序号的比特数量。
- ![](https://cdn.nlark.com/yuque/__latex/d862a6b35ed624e53a2f018f32082825.svg#card=math&code=W_%7BT%7D%3D1&id=vmuzF) 与停止-等待协议相同
- ![](https://cdn.nlark.com/yuque/__latex/45cd13960cd763f408e9220aa7776ffb.svg#card=math&code=W_%7BT%7D%3E2%5E%7Bn-1%7D&id=gpAHd) 接收方无法分辨新、旧数据分组
- 发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去;
- 发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动;若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动。

**接收方**

- 接收窗口尺寸WR的取值范围是1<WR≤W,
- wR = 1 与停止-等待协议相同
- WR > Wt 无意义
- 接收方可接收未按序到达但没有误码并且序号落在接收窗口内的数据分组;
- 为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐━确认!
- 接收方只有在按序接收数据分组后，接收窗口才能向前相应滑动。

随机接入分为总线型局域网和无线型局域网。
总线型局域网使用的是CSMA/CD协议。
无线型局域网使用的是CSMA/CA协议。
多址接入MA：多个主机接在一个总线上，就是一种多址接入现象。
载波监听CS
每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧(“先听后说”) ∶
若检测到总线空闲96比特时间，则发送这个帧;
若检测到总线忙，则继续检测并等待总线转为空闲96比特时间,然后发送这个帧。
IP地址 网络号和主机号的关系：网络号分为ABCDE五类，每一类多占8位作为网络号。
主机号全0代表网络号，全1代表广播地址
# TCP粘包/拆包
UDP无此问题。TCP是个“流”协议，所谓流，就是没有界限的一连串字节流。报文在TCP发送窗口内连续发送，在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。
两个报文连在一起组成TCP报文段发送出去，无法正确切分数据报文，就是粘包
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1629375854006-7c801f0b-aabc-44d2-94ee-723d85a8de13.png#clientId=u3e98ec14-98c5-4&from=paste&height=105&id=u4578c1b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=209&originWidth=994&originalType=binary&ratio=1&size=68573&status=done&style=none&taskId=u90d586e0-410f-4e24-8653-dc94c6fca16&width=497)
一个报文被拆成多个报文发送出去，不好确定包之间的联系，拆包
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1629375864817-bbc36111-a751-4936-ba48-9e8f67640401.png#clientId=u3e98ec14-98c5-4&from=paste&height=185&id=u2b61442f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=1048&originalType=binary&ratio=1&size=135501&status=done&style=none&taskId=u6f20e3a2-f46e-44cd-9b2d-727d83f57da&width=524)
**发生原因：**
1、要发送的数据**大于TCP发送缓冲区剩余空间大小**，将会发生拆包。
 2、待发送**数据大于MSS**（TCP允许应用层传的最大报文长度），TCP在传输前将进行拆包。
 3、要发送的数据**小于TCP发送缓冲区的大小**，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

**粘包问题的解决策略**
（1）消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
（2）在包尾增加回车换行符（特殊符号、转义符、设置边界）进行分割，例如FTP协议；
（3）将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；
（4）更复杂的应用层协议。

Goback—N协议
# 为什么发送窗口不能设置大于8？
因为假如0-7都发送出去了，假如接收方使用累积重传，收到了0-7号，准备接收下一个0号帧，所以发回ack7的确认帧，但是ack7丢失了，引发超时重传，那么这时接收方是准备接收下一批的0号的，而发送方超时重传了之前的0-7号帧，此时接收方收到的0号就重复了，接收方无法分辨新旧数据来处理。
# 熟知端口：

2的16次方个端口号
http:80,https:43,ftp:20/21,sftp:22,smtp:25,dns:53,dhcp:67/68
## 哪些应用层协议使用了tcp
ftp（20传数据，21连接）http，smtp（发邮件，25端口），pop3（收邮件，110端口）
## 哪些应用层协议使用了udp
dns（53端口），snmp（管理网络的，161端口）
## [DNS用的是TCP协议还是UDP协议](https://www.cnblogs.com/wuyepeng/p/9835839.html)
DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？
DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。
**DNS区域传输的时候使用TCP协议：**
1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，**因为数据同步传送的数据量比一个请求应答的数据量要多得多。**
DNS为什么数据量多就要用tcp呢？看上面UDP和TCP的说明。UDP限制了大小为512字节，是因为链路层MTU最大为576字节，而且UDP无法拆分，因为UDP协议首部不带字段，无法分辨报文顺序。
2.TCP是一种可靠连接，保证了数据的准确性。
**域名解析时使用UDP协议：**
客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
# TCP拥塞避免算法
慢开始：拥塞窗口从1开始以2的指数倍增加。
拥塞避免：到达慢开始门限值，采用线性增加，一旦报文段重传计时超时，将门限值降到发生拥塞时窗口的一半大小，使得拥塞窗口变成1。
快重传：不等超时计时器重传，收到三个连续的重复确认，认为发生拥塞，则立即重传报文，并执行快恢复。
快恢复：将拥塞窗口设置成发生拥塞时的窗口大小一半，执行拥塞避免算法。
![](https://cdn.nlark.com/yuque/0/2021/png/21808628/1629187311638-4987a9b0-e9ef-4172-9f25-6d01a09c48ad.png#id=iOyqB&originHeight=493&originWidth=1068&originalType=binary&ratio=1&status=done&style=none)




# 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
二次握手导致已经失效的连接请求报文段突然又传到服务端，产生错误。
可以使用4次握手，3次握手是把ACK和SYN放在一个报文里发送给客户端了，减少了传输开销。按理说四次是可以的，客户端发送连接，服务器确认，然后服务器发送连接，客户端确认，双向确认之后就可以传输了。

建立连接时，服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，不能把这两个报文放一起作为一个阶段来进行三次挥手。


# http状态码：
1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。
200	OK	请求成功。一般用于GET与POST请求
204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档

301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
如果client向server发送post请求。
server返回URL和302。
如果用户确认，client发送post请求。
303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源
304 Not Modified 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户端，原来缓冲的文档还可以继续使用。浏览器将直接调用本地缓存
307 Temporary Redirect 临时重定向。如果原请求不是get或head方法那么就不能自动重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现。
400（错误请求）	服务器不理解请求的语法。

401（未授权）	请求要求身份验证。对于登录后请求的网页，服务器可能返回
此响应。

403（禁止）	服务器拒绝请求。表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。

404（未找到）	
服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。

如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。

如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。

500（服务器内部错误）	服务器遇到错误，无法完成请求。
503（服务不可用）	服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
# 输入网址到显示的过程
从用户输入一个网址到网页最终展现到用户面前，中间的大致流程总结如下：

1) 在客户端浏览器中输入网址URL。
初始机器连接时DHCP获取IP，ARP。。
2) 发送到DNS(域名服务器)获得域名对应的WEB服务器的IP地址。

3) 客户端浏览器与WEB服务器建立TCP(传输控制协议)连接。

4) 客户端浏览器向对应IP地址的WEB服务器发送相应的HTTP或HTTPS请求。

5) WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。

6) 客户端浏览器下载数据，解析HTML源文件，解析的过程中实现对页面的排版，解析完成后，在浏览器中显示基础的页面。

7) 分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。

# Http和Https
**HTTP协议**以**明文方式**发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
安全套接字层超文本传输协议**HTTPS**，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

**对称加密：**所谓对称就是指两边一样 发送方和接收方都用的同一个密钥，加密解密都是同一个密钥从始至终只需要保存一个密钥就行。
**非对称加密：**发送方和接收方使用一对密钥，即公钥和私钥。一般私钥是保密不能被泄露的，公钥可以对外传播。我们可以用公钥加密私钥解密（数据加密） 也可用私钥加密公钥解密（签名下面会解释）

对称加密 速度快 
密钥不可能一开始在发送方和接收方都全部生成好了需要在一方生成之后传递给另一方如果在传递过程密钥被劫持整个加密就不安全了
非对称加密  较安全 
1.加解密速度慢-数据传输效率降低
2.公钥对外公开如果密文是私钥加密那么任何人都能用公钥解密
**混合加密：HTTP综合以上两者的优势！！**知道了两种加密方式的优缺点之后，我们的 HTTPS 就很厉害了，它采用两者混合的加密方式。
**数字签名：**将原文（部分数据关键信息）先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者。

- **Hash 算法计算生成信息摘要**
- **私钥加密生成数字签名**
### https过程：

1. 服务端向 CA 申请数字证书，审核通过后 CA 会向申请者签发认证文件-证书，包含以下内容：

(1) 证书的发布机构CA
(2) 证书的有效期
(3) 发送给客户端的公钥
(4) 证书所有者
(5）签名
（6）信息摘要
....

2. 客户端向服务器发起https请求
2. 服务器传递数字证书给客户端。
2. 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验。

浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发。
如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥，然后对服务器发来的证书里面的签名进行解密。
浏览器使用相同的 Hash 算法根据**证书内容**计算出信息摘要，将这个计算的值与证书解密的hash值信息摘要做对比。
对比结果一致，则证明服务器发来的证书合法，没有被冒充。此时浏览器就可以读取证书中的公钥，用于后续加密了。

5. 用公钥加密对话密钥，发送给服务器
5. 随后双方使用对话密钥进行加密通讯（对称密钥加解密速度更快）

![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1629375377231-20de8c89-a1f7-47a4-b907-06f5c9ed99c7.png#clientId=u3e98ec14-98c5-4&from=paste&id=u888da665&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=1080&originalType=url&ratio=1&size=136811&status=done&style=none&taskId=udaa2370c-e767-451b-b8ae-45c8166b58b)

# TCP/IP四层网络模型

**第一层 网络接口层**

网络接口层包括用于协作IP数据在已有网络介质上传输的协议。

协议：ARP,RARP

**第二层 网间层**

网间层对应于OSI七层参考模型的网络层。负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。

协议：本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，ICMP协议。

**第三层 传输层**

传输层对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。

其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。

**第四层 应用层**

应用层对应于OSI七层参考模型的应用层和表达层。

因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。

# OSI七层网络模型

**第一层 物理层**

作用：负责最后将信息编码成电流脉冲或其它信号用于网上传输。它由计算机和网络介质之间的实际界面组成，可定义电气信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。所有比物理层高的层都通过事先定义好的接口而与它通话。

协议：如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于第一层。

**第二层 数据链路层**

作用：数据链路层通过物理网络链路提供可靠的数据传输。

协议：ATM，FDDI等。 

**第三层 网络层**

作用：这层对端到端的包传输进行定义，他定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。

协议：IP,IPX等

**第四层 传输层**

作用：传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管理及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接收设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到一个物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错恢复包括所采取的行动（如请求数据重发），以便解决发生的任何错误。

协议：TCP，UDP，SPX。

**第五层 会话层**

作用：会话层建立、管理和终止表示层与实体之间的通信会话。通信会话包括发生在不同网络应用层之间的服务请求和服务应答，这些请求与应答通过会话层的协议实现。它还包括创建检查点，使通信发生中断的时候可以返回到以前的一个状态。

协议：RPC，SQL等

**第六层 表示层**

作用：这一层的主要功能是定义数据格式及加密。

协议：FTP,加密

**第七层 应用层**

作用：应用层是最接近终端用户的OSI层，这就意味着OSI应用层与用户之间是通过应用软件直接相互作用的。应用层的功能一般包括标识通信伙伴、定义资源的可用性和同步通信。

协议：telnet，HTTP,FTP,WWW,NFS,SMTP等。


