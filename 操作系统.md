# Linux IO和零拷贝原理
[https://zhuanlan.zhihu.com/p/83398714](https://zhuanlan.zhihu.com/p/83398714)
[https://www.cnblogs.com/xiaolincoding/p/13719610.html](https://www.cnblogs.com/xiaolincoding/p/13719610.html)
kafka 零拷贝 IO
[https://xie.infoq.cn/article/c06fea629926e2b6a8073e2f0](https://xie.infoq.cn/article/c06fea629926e2b6a8073e2f0)



# 线程用户态切换到内核态
涉及到上下文的切换，所以消耗高。

1. 设置处理器至**内核态**。
1. 保存当前寄存器（栈指针、程序计数器、通用寄存器）。
1. 将栈指针设置指向**内核**栈地址。
1. 将程序计数器设置为一个事先约定的地址上，该地址上存放的是系统调用处理程序的起始地址。
# 为什么线程比进程切换要快
最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。
有的同学可能还是不太明白，为什么虚拟地址空间切换会比较耗时呢？
	现在我们已经知道了进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB（translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么**当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。**
# 关于LINUX select/poll/epoll 异步通知机制、阻塞


# 打开文件表和文件描述符
Linux系统中的每个进程会在其进程控制块（PCB）内维护属于自己的文件描述符表（file descriptor table）。
表中每个条目包含两个域：一个条目代表一个文件描述符
一是控制该描述符的标记域（flags）
二是指向系统级别的打开文件表中对应条目的指针
![image.png](https://cdn.nlark.com/yuque/0/2021/png/21808628/1629183465269-ce859c0f-2b4e-484b-b135-9ea947324359.png#clientId=uf02ddeab-26b3-4&from=paste&height=354&id=u23361441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=963&originWidth=1305&originalType=binary&ratio=1&size=503612&status=done&style=none&taskId=u09774fc3-e801-4b43-9b29-ff347c26f29&width=479.5)
一个打开的文件可以对应多个文件描述符（不管是同进程还是不同进程），一个inode也可以对应多个打开的文件。打开文件表中的一行称为一条文件描述（file description），也经常称为文件句柄（file handle）。
在linux中所有一切都抽象为文件，包括读写设备。所以打开文件表，文件描述符其实就是系统所能操控的资源。

	链接：https://www.jianshu.com/p/ad879061edb2
# 进程描述符 类似PCB
 	每个进程都有一个进程描述符，记录以下重要信息：进程标识符、进程当前状态、栈地址空间、内存地址空间、文件系统、打开的文件、信号量等。
# Fork方法
父进程通过Fork创建出来的子进程拥有和父进程完全一样的代码段，数据段，也就是说完完全全拷贝了一份父进程，和父进程完全一样。
**	通过fork的返回值来判断当前进程是父进程还是子进程**。
fork底层是调用了内核的函数来实现fork的功能的，即先create()先创建进程，此时进程内容为空，然后clone()复制父进程的内容到子进程中，此时子进程就诞生了，接着父进程就return返回了。**而子进程诞生后，是直接运行return返回的，然后接着执行后面的程序。**
**这里注意：子进程是不会执行前面父进程已经执行过的程序，因为PCB中记录了当前进程运行到哪里，而子进程又是完全拷贝过来的，所以PCB的程序计数器也是和父进程是相同的，所以是从fork()后面的程序继续执行。**
fork()的时候，父进程的虚拟地址映射着物理内存的实际的物理地址，clone()的时候，并不是在物理地址中直接再复制一份和父进程一样的物理内存块，而是父进程和子进程的虚拟地址都是直接映射到同一物理内存块中，这就是**读时共享**。那这样的话不是就共享变量了吗？不就和前面说的矛盾了吗？ 关键：当你操作这个物理内存块时（比如修改变量的值），再复制该部分的实际物理内存到子进程中，并不是全部复制。这就是**写时复制**。
fork后，父子进程共享父进程的物理空间，会将所有的数据内存页，设置为只读，一旦发生写操作，发生缺页中断，子进程会复制一份页到自己的内存空间中，这里只会复制要写的页，其他页还是不会改变仍然为只读。

# 僵尸进程和孤儿进程
[https://www.cnblogs.com/anker/p/3271773.html](https://www.cnblogs.com/anker/p/3271773.html)
## 概念：
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
## 问题和危害：
对于僵尸进程来说，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其**进程号就会一直被占用**，但是**系统所能使用的进程号是有限的**，如果大量的产生僵死进程，将因为没有可用的进程号而导致**系统不能产生新的进程**. 此即为僵尸进程的危害，应当避免。
孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上。**每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程**。因此孤儿进程并不会有什么危害。
  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

# 进程和线程切换的代价
https://www.jb51.net/article/102004.htm
**进程切换分两步：**
**1.切换页目录以使用新的地址空间**
**2.切换内核栈和硬件上下文**
对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。
**切换的性能消耗：**
1、线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。
2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）快表失效或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。
系统调用：处于进程上下文
系统调用是在进程上下文中,并没有tasklet之类的延迟运行,系统调用本身可以休眠,这些可以参见内核代码
虽然系统调用实与其他中断实现有点类似,通过IDT表查找入口处理函数,但是系统调用与其他中断最大的不同是,系统调用是代表当前进程执行的,所以current宏/task_struct是有意义的,这个休眠可以被唤醒
系统调用，异常，中断（其中中断是异步时钟，异常时同步时钟），也可以把系统调用成为异常
中断上下文：在中断中执行时依赖的环境，就是中断上下文（不包括系统调用，是硬件中断）
进程上下文：当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文
1、首先，这两个上下文都处于内核空间。
2、其次，两者的区别在于，进程上下文与当前执行进程密切相关，而中断上下文在逻辑上与进程没有关系。
进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等。所以在进程上下文中引用current是有意义的。
内核进入中断上下文是因为中断信号而导致的中断处理或软中断。而中断信号的发生是随机的，中断处理程序及软中断并不能事先预测发生中断时当前运行的是哪个进程，所以在中断上下文中引用current是可以的，但没有意义。事实上，对于A进程希望等待的中断信号，可能在B进程执行期间发生。例如，A进程启动写磁盘操作，A进程睡眠后现在时B进程在运行，当磁盘写完后磁盘中断信号打断的是B进程，在中断处理时会唤醒A进程。
上下文这个词会让人想到进程的CPU寄存器状态，但好像进入进程上下文（异常处理系统调用）和进入中断上下文（中断处理），内核所做的工作没有太大区别。所以，这两个上下文的主要区别，我认为在于是否与进程相关。
运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。因此，内核会限制中断上下文的工作，不允许其执行如下操作：
**(1) 进入睡眠状态或主动放弃CPU;**
由于中断上下文不属于任何进程，它与current没有任何关系（尽管此时current指向被中断的进程），所以中断上下文一旦睡眠或者放弃CPU，将无法被唤醒。所以也叫原子上下文（atomic context）。
**(2) 占用互斥体;**
为了保护中断句柄临界区资源，不能使用mutexes。如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况，如果必须使用锁，则使用spinlock。
**(3) 执行耗时的任务;**
中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。在中断处理例程中执行耗时任务时，应该交由中断处理例程底半部来处理。
**(4) 访问用户空间虚拟内存。**
因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在中断上下文无法访问用户空间的虚拟地址
**(5) 中断处理例程不应该设置成reentrant（可被并行或递归调用的例程）。**
因为中断发生时，preempt和irq都被disable，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，是不允许在SMP上并发运行的。
**(6)中断处理例程可以被更高级别的IRQ中断。**（不能嵌套中断）使用软中断，上部分关中断，也就是禁止嵌套，下半部分使用软中断
如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。
软中断是一种延时机制，代码执行的优先级比进程要高，比硬中断要低。相比于硬件中断，软中段是在开中断的环境中执行的（长时间关中断对系统的开销太大），代码是执行在中断/线程上下文的，是不能睡眠的，虽然每个cpu都有一个对应的ksoftirqd/n线程来执行软中断，但是do_softirq这个函数也还会在中断退出时调用到，因此不能睡眠(中断上下文不能睡眠的原因是由于调度系统是以进程为基本单位的，调度时会把当前进程的上下文保存在task_struct这个数据结构中，当进程被调度重新执行时会找到执行的断点，但是中断上下文是没有特定task_struct结构体的，当然现在有所谓的线程话中断，可以满足在中断处理函数执行阻塞操作，但是实时性可能会有问题。还有就是中断代表当前进程执行的概念，个人感觉有点扯淡，毕竟整个内核空间是由所有进程共享的，不存在代表的概念)
上面我们介绍的可延迟函数运行在中断上下文中（软中断的一个检查点就是do_IRQ退出的时候），于是导致了一些问题：软中断不能睡眠、不能阻塞。由于中断上下文出于内核态，没有进程切换，所以如果软中断一旦睡眠或者阻塞，将无法退出这种状态，导致内核会整个僵死。但可阻塞函数不能用在中断上下文中实现，必须要运行在进程上下文中，例如访问磁盘数据块的函数。因此，可阻塞函数不能用软中断来实现。但是它们往往又具有可延迟的特性。

